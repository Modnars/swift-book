{"./":{"url":"./","title":"说明","keywords":"","body":"Swift 编程语言 说明         这是我尝试翻译的第一本编程书籍。我曾无数次心血来潮地想要学习 Swift 编程语言与 iOS 程序设计开发，但很多时候都又深感国内相关基础知识内容的匮乏。值得惊喜与肯定的是，国内有诸多优秀的同学致力于改善这一现状，比如 SwiftGG 翻译组已经对这一教程做了完整详细的翻译。那么我为什么还要尝试对这本书进行翻译呢？         从内容翻译本身来讲，翻译的人不同，对词汇理解、语法运用的能力本就难以一致，加上对编程语言本身的理解，也可能导致输出的结果与本义可能有失精准。为了尽可能地避免多人翻译导致的这种细节差异性，我决定尝试独立完整地将书中内容尽可能详尽地翻译下来。我想这将是对我自己能力的锻炼与提升，同时希望也能更好地帮助需要这些知识内容的人。 参考 英文在线原版 The Swift Programming Language SwiftGG翻译组中文译版 The Swift Programming Language in Chinese "},"WelcomeToSwift/":{"url":"WelcomeToSwift/","title":"欢迎","keywords":"","body":"欢迎 "},"WelcomeToSwift/AboutSwift.html":{"url":"WelcomeToSwift/AboutSwift.html","title":"关于 Swift","keywords":"","body":"关于 Swift         Swift 是编写软件的一种极好的方式，无论这些软件是运行于手机、电脑、服务器或是任何可以运行代码的平台。它是一门安全、高效而又可交互的，集结了当今编程语言最棒思路的语言，这些智慧的思路来自于 Apple 饱含智慧的工程师文化以及 Swift 开源社区丰富多样的贡献。其编译器致力于性能优化，语言本身致力于高效开发，二者均是特色亮点。         Swift 是一门对新手程序员友好的语言。它不仅是拥有高可读性的工业级编程语言，也是一门有趣的脚本语言。在 Playground 模式下来写 Swift 代码可以让你即刻看到运行结果，而不必等待完整的构建、运行应用程序的完整流程。         Swift 通过采用现代编程模式避免了诸多类型的常见语言错误： 变量在使用前要完成初始化 对数组下标进行越界检查 对整数类型进行溢出检查 用可选值类型确保 nil 值可以被准确处理 自动化管理内存空间 通过异常处理来保证程序可以从未知错误中恢复控制流程         Swift 代码的编译及优化已经使得它可以更好地适配发挥硬件的性能。它的语法解析和标准库的设计，都基于“简洁明确的编码，高效运行的性能”这一指导性原则。它对于安全性和高效性的结合，使得无论是编写一个简单的“Hello, world!”程序，亦或是实现一个完整的操作系统，都值得考虑 Swift 是否是这些场景的绝佳选择。         Swift 汇聚了强大的类型推导，并且可以保证它的编码模式拥有现代化、轻量级语法、可将复杂思考逻辑表达为简洁直观的行为的特点。这样一来，代码不仅更容易编写，也更容易阅读理解以及维护。         Swift 历经数年用以实现，并且它依旧会带着新特性、对历史版本的适配性进化衍生。我们对于 Swift 是饱含信心的。我们已经迫不及待地期待它在你的手中大放异彩。 "},"WelcomeToSwift/VersionCompatibility.html":{"url":"WelcomeToSwift/VersionCompatibility.html","title":"版本适配","keywords":"","body":"版本适配         本书所述均为 Swift 5.7 版本内容，这也是 Xcode 14 中的默认 Swift 版本。你可以在 Xcode 14 中用 Swift 5.7, Swift 4.2 或 Swift 4 来编码并构建目标。         当你用 Xcode 14 来构建 Swift 4 和 Swift 4.2 的代码时，Swift 5.7 的大部分功能都是可供支持的。但需要说明的是，以下的变动内容仅在使用 Swift 5.7 或更高版本时才可供支持： 返回值类型为不透明类型的函数需要 Swift 5.1 运行时支持。 try? 表达式不会为已经返回可选值的表达式提供额外的层级选择性。 更大的整数型字面值的初始化表达式可以被推导为更准确的整数型。比如， UInt64(0xffff_ffff_ffff_ffff) 可以被准确地按其字面值来推导，而不是反馈数值溢出。         对并发性而言，需要 Swift 5.7 或更高版本，以及拥有 Swift 标准库来提供相应并发性类型的版本。对于 Apple 现有平台而言，目标的版本需要至少设定为 iOS 15，macOS 12，tvOS 15 或 watchOS 8.0。         使用 Swift 5.7 编码的目标可以依赖于使用 Swift 4.2 或 Swift 4 编写的目标，反之亦然。也就是说，如果你已有一个可划分为多个框架的巨大工程，你可以将你的框架代码逐步从 Swift 4 迁移至 Swift 5.7。 "},"WelcomeToSwift/ASwiftTour.html":{"url":"WelcomeToSwift/ASwiftTour.html","title":"Swift 之旅","keywords":"","body":"Swift 之旅         按照编程传统，使用一门新的编程语言编码的第一个程序往往应当是在屏幕上打印“Hello, world!”。那么对于 Swift 而言，仅需一行代码即可完成： print(\"Hello, world!\") // 打印“Hello, world!”         如果你曾编写过 C 或 Objective-C 的代码，那么这样的语法对你来说可能是很熟悉的。在 Swift 中，这样的一行代码就已经是一个完整的程序了。你甚至无需为此导入一个独立的库来支持类似于输入或输出、字符串处理的功能。写在全局范围内的代码被视为程序的执行起点，所以你也无需为此添加一个 main() 函数。甚至，你也无需在每行代码语句的末尾添加分号。         这场 Swift 之旅将向你展示如何完成各种各样的编程任务，并以此来为你提供开始用 Swift 编程的足够信息。不必担心你可能对某些内容不够理解，因为初程中介绍的每个内容，后续章节中都会有详细的解释说明。 说明         为了最佳的练习体验，可将本章内容作为一个 Playground 内容在 Xcode 中打开。Playground 可以让你编辑完代码就可以立即看到它们的运行结果。         下载 Playground 简单值         使用 let 关键字可以创造一个常量，而使用 var 关键字可以创造一个变量。编译阶段不必确定常量的具体值，但一定要你一次性地为它赋予一个确定值。也就是说，你可以用一个常量来作为你可以一次性确定又要在很多地方使用到的值。 var myVariable = 42 myVariable = 50 let myConstant = 42         无论是常量还是变量，其类型都必须要与为其赋予的值的类型一致。然而，你无需总是要显式地指定值的类型。当你创造一个常量或变量并对其进行赋值时，编译器就会自动按照所赋值的类型推导其类型。在上面的例子中，编译器推导出 myVariable 是整数类型，因为它的初始值就是一个整数。         当然，如果初始值无法提供足够的信息（或者甚至都没有初始值），可以在变量（常量）名之后指定其具体类型，中间用冒号 : 隔开。 let implicitInteger = 70 let implicitDouble = 70.0 let explicitDouble: Double = 70 实践         创造一个常量，将其类型指定为 Float 并为其赋值为 4         值永远不会隐式转换为另一种类型。如果你需要将值转换为一个不同的类型，则需要显示地构造一个所需类型的实例。 let label = \"The width is \" let width = 94 let widthLabel = label + String(width) 实践         尝试从最后一行代码中移除掉 String 。看看这时编译器会向你提示什么错误？         其实，当字符串中包含一些值时，有一种更简单的写法：可以将目标值写在小括号（ ( 和 ) ）内，并且在左括号前加一个反斜杠（ \\ ）。举个例子： let apples = 3 let oranges = 5 let appleSummary = \"I have \\(apples) apples.\" let fruitSummary = \"I have \\(apples + oranges) pieces of fruit.\" 实践         使用 \\() 来将一个浮点数算式放入一个字符串中，并且尝试将某个人的名字放到一句问候的字符串中。         可以使用三个双引号（ \"\"\" ）来界定那些可能占据多行文本的字符串。引号界定范围内的每行文本前的缩进都将被移除，直到它匹配到终止界定引号符。举个例子： let quotation = \"\"\" I said \"I have \\(apples) apples.\" And then I said \"I have \\(apples + oranges) pieces of fruit.\" \"\"\"         创建数组和字典这样的容器时，可以使用中括号（ [ 和 ] ），并且访问它们的元素时，只需要在中括号中填写要访问的下标或键值即可。（需要给定其字面值时，可以用元素列表的形式，元素间用逗号（ , ）分隔，）列表中最后一个元素的后面也可以跟填一个逗号。 var shoppingList = [\"catfish\", \"water\", \"tulips\"] shoppingList[1] = \"bottle of water\" var occupations = [ \"Malcolm\": \"Captain\", \"Kaylee\": \"Mechanic\", ] occupations[\"Jayne\"] = \"Public Relations\"         当你向数组中添加元素时，数组自然也会随之增长。 shoppingList.append(\"blue paint\") print(shoppingList)         当需要创造一个空的数组或字典时，就需要使用初始化语句（注意需要填充指定元素类型）。 let emptyArray = [String]() let emptyDictionary = [String: Float]()         如果容器的类型信息可以被推导出来，那么你就可以用 [] 来表示一个空数组，用 [:] 来表示一个空字典。比如说，当你为一个（已经确定类型的）变量赋予新值或者传递参数给一个函数时，那这个新值、参数值就可以是这样的空数组、空字典。 shoppingList = [] occupations = [:] 控制流         使用 if 和 switch 关键字来创建条件语句，使用 for-in ， repeat-while 关键字来创建循环语句。条件或循环变量两边的小括号是可选的，而控制语句逻辑内的主体则必须要用大括号来界定。 let individualScores = [75, 43, 103, 87, 12] var teamScore = 0 for score in individualScores { if score > 50 { teamScore += 3 } else { teamScore += 1 } } print(teamScore) // 打印 “11”         对于一个 if 语句，其条件语句必须是一个布尔类型的表达式，这也就是说对于类似 if score { ... } 这样的代码就是错误的，因为条件本身并不会（像 C 语言一样）是一个隐式判断是否为零的布尔表达式。         你可以使用 if 和 let 组合来应对那些值可能不存在的情况。这些值可能不存在的类型被称为可选值类型，可选值类型的变量或常量就是可选值。一个可选值要么确实拥有一个值，要么就只是一个 nil 来表示它的值的确不存在。在一个值的类型标识后使用问号符（ ? ）来表示这个值是一个可选值。 var optionalString: String? = \"Hello\" print(optionalString == nil) // 打印 “false” var optionalName: String? = \"John Appleseed\" var greeting = \"Hello!\" if let name = optionalName { greeting = \"Hello, \\(name)\" } 实践         将 optionalName 的值改为 nil 。此时你得到的问候语句内容是什么？针对 optionalName 为 nil 的情况添加一个 else 语句来设定一个不同的问候（ greeting 变量）内容。         如果可选值是 nil ，那么条件语句的结果将会是 false ，继而大括号中的逻辑内容将会被跳过执行。否则，可选值就会被解包并且赋值给 let 关键字后面的常量，而这个常量就可以使得解包后的值可以在这段代码块中被使用了。         另一种处理可选值的方式是使用 ?? 操作符（ operator ，在 C 、 C++ 中常被译为运算符）来为其提供一个默认值。如果可选值的确缺失了，那么就将使用默认值来替换。 let nickName: String? = nil let fullName: String = \"John Appleseed\" let informalGreeting = \"Hi \\(nickName ?? fullName)\"         你也可以用一种更简短的编码来解包一个值，这时可以对这个解包后的值使用相同的名字。 if let nickname { print(\"Hey, \\(nickname)\") }         switch 语句支持任意类型的数据以及更加广泛的比较操作，这些比较不只适用于整数型，且比较不止判断是否相等这一种。 let vegetable = \"red pepper\" switch vegetable { case \"celery\": print(\"Add some raisins and make ants on a log.\") case \"cucumber\", \"watercress\": print(\"That would make a good tea sandwich.\") case let x where x.hasSuffix(\"pepper\"): print(\"Is it a spicy \\(x)?\") default: print(\"Everything tastes good in soup.\") } 实践         尝试移除上面的默认情况（ default case ），看看这时编译器会提示什么错误？         请留意 let 是如何被用于模式条件匹配情况时给常量赋值的。         当执行完一段 switch 语句的条件匹配逻辑时，程序执行流程将会从 switch 语句中退出。程序并不会（像 C 那样）在下一个条件匹配逻辑中继续执行，所以你也无需在每个条件匹配逻辑流程最后显示地指定退出。         你可以用一对标识符来表示一个键值对，并用这样的方式来迭代遍历一个字典中的所有元素。字典是一个无序的集合（容器），所以遍历得到的也可能是一个按照随意的顺序排列的结果。 let interestingNumbers = [ \"Prime\": [2, 3, 5, 7, 11, 13], \"Fibnoacci\": [1, 1, 2, 3, 5, 8], \"Square\": [1, 4, 9, 16, 25], ] var largest = 0 var kindLabel = \"\" for (_, numbers) in interestingNumbers { for number in numbers { if number > largest { largest = number } } } print(largest) // 打印最大值 “25” 实践         用一个变量名替换 _ ，并且追踪哪种数列中的值是最大值。         使用 while 关键字来循环执行一段代码直到循环条件发生变化（不再满足继续循环的条件）。循环语句的循环条件可以在循环体后来给定，此时可以确保这个循环体至少执行了一次。 var n = 2 while n         你也可以用 .. 来为下标创建一个区间。 var total = 0 for i in 0..         使用 .. 可以创建一个不包括右界（区间最大值）的区间（左闭右开区间），也可以使用 ... 来创建一个包含左右界的区间（闭区间）。 函数与闭包         使用 func 关键字来声明一个函数，而调用这个函数的时候只需要函数名字后跟小括号和参数列表即可。声明函数时，使用 -> 来分隔函数的参数列表（由参数名字和参数类型组成）和函数的返回值。 func greet(person: String, day: String) -> String { return \"Hello \\(person), today is \\(day).\" } greet(person: \"Bob\", day: \"Tuesday\") 实践         移除掉函数参数 day ，添加一个参数来将今天的特价午餐置入问候句中。         默认情况下，函数外部使用其参数名称作为其调用时的参数标签。你也可以为参数单独添加一个调用时使用的参数标签，或者使用 _ 来表示调用时不需要填写参数标签。 func greet(_ person: String, on day: String) -> String { return \"Hello \\(person), today is \\(day).\" } greet(\"John\", on: \"Wednesday\")         使用元组来创建一个组合值。比如一些函数就希望返回多种类型的组合值，访问这样的组合值时，既可以用它们的字段名来访问，也可以用它们按序出现的下标来访问（下标从0开始）。 func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) { var min = scores[0] var max = scores[0] var sum = 0 for score in scores { if score > max { max = score } else if score         函数是可以被嵌套定义的，嵌套的函数可以访问外层函数体的变量。你可以使用嵌套函数来整理代码更多或逻辑更复杂的函数。 func returnFifteen() -> Int { var y = 10 func add() { y += 5 } add() return y } returnFifteen()         在 Swift 中，函数是第一类型1，这也就意味着函数本身也是可以作为函数返回值的。 func makeIncrementer() -> ((Int) -> Int) { func addOne(number: Int) -> Int { return 1 + number } return addOne } var increment = makeIncrementer() increment(7)         同理，一个函数也可以作为另一个函数的参数。 func hasAnyMaches(list: [Int], condition: (Int) -> Bool) -> Bool { for item in list { if condition(item) { return true } } return false } func lessThanTen(number: Int) -> Bool { return number         实际上，在 Swift 中，函数是一种特殊的闭包（ closure ），而闭包指的就是可以稍后被调用的一段代码。当闭包被定义时，闭包内的代码是可以访问此闭包所在范围内的其他变量的，尽管这个闭包实际执行时可能已经不再属于这个范围内。当然，前面关于嵌套函数的示例代码已经证明了这一点。更简便地，你也可以直接用大括号（ {} ）来界定一段代码从而定义一个匿名闭包。使用 in 关键字来分隔闭包声明和闭包实现逻辑代码。 numbers.map({ (number: Int) -> Int in let result = 3 * number return result }) 实践         重写这个闭包来实现传入奇数时返回零。         其实，很多场景下你还可以让这个闭包的定义更加精简。比如对于一个代理的回调闭包，此时的闭包类型（传入参数类型、返回值类型）都可以确定，那么此时就可以进一步省略它的参数类型声明或返回值类型声明。如果闭包中只包含一行语句，那么闭包就将返回这行语句的值，并认为这行语句值的类型就是闭包的返回值类型。 let mappedNumbers = numbers.map({ number in 3 * number }) print(mappedNumbers)         进一步地，你还可以使用标号来访问传入参数来取代使用其名字访问，这样一来，对于简短的闭包来说这将格外适用。当闭包作为一个函数的最后一个参数时，它就可以直接跟在函数调用的小括号后面。当这个闭包同时是这个函数的唯一参数时，你甚至可以省略掉函数调用的小括号。 let sortedNumbers = numbers.sorted { $0 > $1 } print(sortedNumbers) // 打印“[20, 19, 12, 7]” 对象与类         使用 class 关键字后跟一个类名标识符来创建一个类。类中定义字段的方式和以前定义常量、变量的方式一致，区别就是此时定义的字段的上下文是类空间。同理，函数方法的声明也与之前一致。 class Shape { var numberOfSides = 0 func simpleDescription() -> String { return \"A shape with \\(numberOfSides) sides.\" } } 实践         使用 let 关键字创建一个常量字段，并且添加另一个需要传入一个参数的函数方法。         使用类名后跟小括号的方式就可以构造一个属于此类的对象。使用圆点符号来访问这个对象的指定字段或调用这个对象的指定方法。 var shape = Shape() shape.numberOfSides = 7 var shapeDescription = shape.simpleDescription()         这样定义的 Shape 类是缺少了很重要的一部分内容的，这部分内容就是就是类的初始化构造器（构造函数），构造器用于定义创建对象时初始化的一些逻辑。使用 init 关键字来定义构造函数。 class NamedShape { var numberOfSides = 0 var name: String init(name: String) { self.name = name } func simpleDescription() -> String { return \"A shape with \\(numberOfSides) sides.\" } }         请注意，在构造函数中使用 self 来区分哪个 name 是传入参数，哪个 name 是类的字段。当你创建一个类的对象时，相应参数就和函数参数一样传递给构造函数。无论是在声明时（就像 numberOfSides ），还是在构造函数中（就像 name ），每个字段都需要被赋值。         如果在对象被销毁前你需要执行一些必要的清理逻辑，你可以用 deinit 关键字来创建一个析构函数。         子类可以在定义时通过分号后跟父类名字来实现继承。对于类来说没有必须要严格继承的根类型，所以你可以按需继承或省略一个父类。         在子类中覆写父类的方法需要用 override 关键字来标识，如果你没有使用 override 却又覆写了父类的方法实现，那么此时编译器就会认为这是个错误。当然，如果你用了 override 来标识，编译器却发现你并未覆写任何父类方法实现，编译器也会认为这是个错误。 class Square: NamedShape { var sideLength: Double init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) numberOfSides = 4 } func area() -> Double { return sideLength * sideLength } override func simpleDescription() -> String { return \"A square with sides of length \\(sideLength).\" } } let test = Square(sideLength: 5.2, name: \"my test square\") test.area() test.simpleDescription() 实践         创建一个名为 Circle 的 NamedShape 的子类，这个子类需要一个半径值和名字作为它构造时所需的参数。请为这个 Circle 类实现它的 area() 和 simpleDescription() 函数方法。         属性字段除了用于简单的存储，还可以为他们设定 get 方法和 set 方法。 class EquilateralTriangle: NamedShape { var sideLength: Double = 0.0 init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) numberOfSides = 3 } var perimeter: Double { get { return 3.0 * sideLength } set { sideLength = newValue / 3.0 } } override func simpleDescription() -> String { return \"An equilateral triangle with sides of length \\(sideLength).\" } } var triangle = EquilateralTriangle(sideLength: 3.1, name: \"a triangle\") print(triangle.perimeter) // 打印“9.3” triangle.perimeter = 9.9 print(triangle.sideLength) // 打印“3.3000000000000003”         在 perimeter 的 set 方法中，新值有一个隐式的名字： newValue 。你也可以在 set 后面在小括号中设定一个指定的名字。         请注意， EquilateralTriangle 类的构造函数有三个步骤： 为子类中声明的字段赋值 调用父类的构造函数 修改父类定义的字段值。任何其余的函数方法、 get 函数或 set 函数也都会在这个准备阶段完成准备。         如果你无需计算属性值却又需要在更新一个字段值前后做一些逻辑，那么你就可以使用 willSet 和 didSet 关键字。这部分逻辑代码将会在除构造函数之外，任何修改指定变量的时候被执行。举例来说，下面这个类中的 triangle 的长度将会一直和它的 square 的长度保持一致。 class TriangleAndSquare { var triangle: EquilateralTriangle { willSet { square.sideLength = newValue.sideLength } } var square: Square { willSet { triangle.sideLength = newValue.sideLength } } init(size: Double, name: String) { square = Square(sideLength: size, name: name) triangle = EquilateralTriangle(sideLength: size, name: name) } } var triangleAndSquare = TriangleAndSquare(size: 10, name: \"another test shape\") print(triangleAndSquare.square.sideLength) // 打印“10.0” print(triangleAndSquare.triangle.sideLength) // 打印“10.0” triangleAndSquare.square = Square(sideLength: 50, name: \"larger square\") print(triangleAndSquare.triangle.sideLength) // 打印“50.0”         当处理可选值时，你可以在调用函数方法、访问字段属性和下标访问这类操作前加 ?。如果 ? 之前的值是一个 nil ，那么 ? 之后的任何内容都将会被忽略并且整个表达式将返回一个 nil 。否则，这个可选值就将被正常解包，并且 ? 之后的内容都可以正常执行解包后的值的指定逻辑。这两种情况下，表达式返回值类型都是可选值类型。 let optionalSquare: Square? = Square(sideLength: 2.5, name: \"optional square\") let sideLength = optionalSquare?.sideLength 枚举与结构体         使用 enum 关键字来创建枚举类。与类和其他命名类型一样，枚举值也有它们自己的函数方法。 enum Rank: Int { case ace = 1 case two, three, four, five, six, seven, eight, nine, ten case jack, queen, king func simpleDescription() -> String { switch self { case .ace: return \"ace\" case .jack: return \"jack\" case .queen: return \"queen\" case .king: return \"king\" default: return String(self.rawValue) } } } let ace = Rank.ace let aceRawValue = ace.rawValue 实践         定义一个函数来实现通过 Rank 类的原始值来对其枚举值进行比较。         默认情况下，Swift 会为枚举值从零开始赋值给其原始值，逐个递增 1 。但你也可以改变这种默认的行为通过显式指定枚举值的具体原始值。比如上面的示例代码， Ace 就被显式指定原始值为 1 ，然后接下来每个枚举值的原始值都按序递增 1 。你也可以用字符串或浮点数来作为一个枚举值的原始值。使用 rawValue 来访问一个枚举值的原始值。         使用 init?(rawValue:) 这样的构造函数获取一个通过原始值构造的枚举值。如果原始值正确匹配了相应的枚举值，它就会返回相应的枚举值，否则将会返回一个 nil 。 if let convertedRank = Rank(rawValue: 3) { // let threeDescription = convertedRank.simpleDescription() let _ = convertedRank.simpleDescription() }         枚举值就是一个实际的值，而不是他们原始值的另一种写法。实际上，为了避免枚举值可能难以确定一个有意义的原始值的情况，你甚至无需指定或使用它们的原始值。 enum Suit { case spades, hearts, diamonds, clubs func simpleDescription() -> String { switch self { case .spades: return \"spades\" case .hearts: return \"hearts\" case .diamonds: return \"diamonds\" case .clubs: return \"clubs\" } } } let hearts = Suit.hearts let heartsDescription = hearts.simpleDescription() 实践         为 Suit 枚举类定义一个 color() 函数方法，当枚举值为黑桃、梅花时返回 \"black\" ，当枚举值为红心和方块时返回 \"red\" 。         请注意示例代码中，指定 hearts 枚举值时有用到两种写法。当赋值给 hearts 常量时，枚举值使用了完整的 Suit.hearts，这是因为这个常量在赋值前对于枚举值的类型一无所知。而在 switch 语句中，可以通过一种简短的 hearts 来指定相应枚举值，这是因为此时的 self 的类型已经确定是一个 Suit 枚举类型了。你可以在任意已知变量类型为枚举类的情况下使用相应的简短模式来确定相应的枚举值。         如果枚举类拥有原始值，那么这些原始值就被认为是相应枚举类定义内容的一部分，这也就意味着两个不同的枚举值实例有着相同的原始值。而枚举值可以拥有另一种属性值类型——绑定值。这些绑定值只有在创建了具体的枚举值实例时才被确定下来。你可以认为绑定值就像是枚举值实例的存储字段。举例来说，有一种场景需要向服务器请求获取日出、日落的时间。那么对于服务器的响应内容来说，要么返回相应的日出、日落时间信息，要么返回请求失败并附带相应的错误原因。 enum ServerResponse { case result(String, String) case failure(String) // EXPERIMENT: // Add a third case to `ServerResponse` and to the switch. case offline(Void) } let success = ServerResponse.result(\"6:00 am\", \"8:09 pm\") let failure = ServerResponse.failure(\"Out of cheese.\") switch success { case let .result(sunrise, sunset): print(\"Sunrise is at \\(sunrise) and sunset is at \\(sunset)\") case let .failure(message): print(\"Failure... \\(message)\") } // 打印 \"Sunrise is at 6:00 am and sunset is at 8:09 pm.\" 实践         为 ServerResponse 枚举类添加第三种枚举值，并完善示例代码中的 switch 语句。         请留意 switch 语句中，日出、日落时间是如何从 ServerResponse 类型的枚举值中提取出来的。         使用 struct 关键字来创建一个结构体。结构体支持和类相同的诸多行为，比如函数方法和构造函数。二者最大的区别就是，结构体在传递给新的值时需要完整拷贝，是值传递，而类传递给新的值时只是传递一个引用，是引用传递。 struct Card { var rank: Rank var suit: Suit func simpleDescription() -> String { return \"The \\(rank.simpleDescription()) of \\(suit.simpleDescription())\" } } let threeOfSpades = Card(rank: .three, suit: .spades) let threeOfSpadesDescription = threeOfSpades.simpleDescription() 实践         创建一个可以返回一整副包含所有牌面值和花色组合的牌的函数方法。 并发         使用 async 来标识一个函数运行时异步执行。 func fetchUserID(from server: String) async -> Int { if server == \"primary\" { return 97 } return 501 }         按照异步方式调用一个异步函数时需要在其前方填写 await 。 func fetchUsername(from server: String) async -> String { let userID = await fetchUserID(from: server) if userID == 501 { return \"John Appleseed\" } return \"guest\" }         使用 async let 来调用一个异步函数，这样可以使得它与其他异步代码并发执行。当你需要使用它的返回值时，就填写 await 。 func connectUser(to server: String) async { async let userID = fetchUserID(from: server) async let username = fetchUsername(from: server) let greeting = await \"Hello \\(username), user ID `(userID)\" print(greeting) }         使用 Task 来调用由异步代码定义且无需等待返回值的异步函数。 Task { await connectUser(to: \"primary\") } // 打印 \"Hello Guest, user ID 97\" 协议与拓展         使用 protocol 关键字来定义一个协议。 protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() }         类、枚举类以及结构体都可以遵循协议。 class SimpleClass: ExampleProtocol { var simpleDescription: String = \"A very simple class.\" var anathorProperty: Int = 69105 func adjust() { simpleDescription += \" Now 100% adjusted.\" } } var a = SimpleClass() a.adjust() let aDescription = a.simpleDescription struct SimpleStructure: ExampleProtocol { var simpleDescription: String = \"A simple structure\" mutating func adjust() { simpleDescription += \" (adjusted)\" } } var b = SimpleStructure() b.adjust() let bDescription = b.simpleDescription 实践         为 ExampleProtocol 添加另一个必要内容。那么你需要如何修改来确保 SimpleClass 和 SimpleStructure 依然遵守这一协议？         注意在 SimpleStructure 的声明中使用 mutating 关键字来标识一个可能改变自身属性字段值的函数方法。而 SimpleClass 无需对其方法做类似的标记，是因为类的函数方法修改的总是自身的属性字段。         使用 extention 来为一个已存在的类型添加拓展功能，比如新的函数方法或计算属性。你可以使用拓展来确保其他地方定义的类、或是你导入的库或框架中所含的类能够遵循指定的协议。 extension Int: ExampleProtocol { var simpleDescription: String { return \"The number \\(self)\" } mutating func adjust() { self += 42 } } print(7.simpleDescription) // 打印 \"The number 7\" 实践         使用拓展来为 Double 类添加一个 absoluteValue （绝对值）属性字段。         你可以像其他命名类型一样使用协议的名字，比如说你可以创建一个遵循相同协议的集合，尽管集合中元素的具体类型可能不尽相同。当你使用一个类型为协议的值时，那么不是由协议声明的函数方法将不再可用。 let protocolValue: ExampleProtocol = a print(protocolValue.simpleDescription) // 打印\"A very simple class. Now 100% adjusted.\" // print(protocolValue.anotherProperty) // 移除注释符，看看编译器会提示什么错误？         尽管 protocolValue 的运行时类型为 SimpleClass ，但编译器仍将其视为给定的 ExampleProtocol 类型。这也就表明你不能错误地访问那些由类额外定义而非其类所遵从的协议声明的函数方法或属性字段。 错误处理         你可以使用遵从 Error 协议的类型来表示错误。 enum PrinterError: Error { case outOfPaper case noToner case onFire }         使用 throw 来抛出一个错误并用 throws 来标识一个可能抛出错误的函数。如果你在一个函数中抛出了错误，那么这个函数会立即返回并执行能够处理相应错误的代码逻辑。 func send(job: Int, toPrinter printerName: String) throws -> String { if printerName == \"Never Has Toner\" { throw PrinterError.noToner } return \"Job sent\" }         有几种方式来处理错误。一种方式是使用 do-catch 。在 do 的代码块中，你可以在那些可能抛出错误的代码前标记 try 。而在 catch 代码块中，被抛出的错误就会被自动命名为 error ，你也可以为它赋予另一个不同的名字。 do { let printerResponse = try send(job: 1040, toPrinter: \"Bi Sheng\") print(printerResponse) } catch { print(error) } // 打印 \"Job sent\" 实践         将打印机的名字修改为 \"Never Has Toner\" (从来没有碳粉)，以此来保证 send(job: toPrinter:) 函数会抛出一个错误。         你也可以提供多种 catch 块来处理具体的错误类型。你可以在 catch 后面添加匹配条件，模式和 switch 语句中 case 后面的匹配条件类似。 do { let printerResponse = try send(job: 1040, toPrinter: \"Gutenberg\") print(printerResponse) } catch PrinterError.onFire { print(\"I'll just put this over here, with the rest of the fire.\") } catch let printerError as PrinterError { print(\"Printer error: \\(printerError).\") } catch { print(error) } // 打印 \"Job sent\" 实践         补充代码以使得 do 代码块中会抛出异常。那么你需要抛出什么类型的错误才能使得错误被第一个 catch 块处理？那为了被第二个、第三个代码块处理，又该如何呢？         另一种处理错误的方式是使用 try? 来将结果转换为一个可选值。如果函数内抛出了错误，那么这个错误就直接被丢弃并且外层得到的结果就是一个 nil 。否则，结果就是拥有函数返回值的可选值。 let printerSuccess = try? send(job: 1884, toPrinter: \"Mergenthaler\") let printerFailure = try? send(job: 1885, toPrinter: \"Never Has Toner\")         使用 defer 来定义那些在函数返回前务必执行的代码。这些代码即使是函数内抛出了错误也会被执行到。你可以使用 defer 来将函数中初始执行代码和结束时执行代码相邻放置，尽管他们实际上需要在不同时机来执行。 var fridgeIsOpen = false let fridgeContent = [\"milk\", \"eggs\", \"leftovers\"] func fridgeContains(_ food: String) -> Bool { fridgeIsOpen = true defer { fridgeIsOpen = false } let result = fridgeContent.contains(food) return result } fridgeContains(\"banana\") print(fridgeIsOpen) // 打印 \"false\" 泛型         在尖角括号中添加名字来创建一个泛型函数或类型。 func makeArray(repeating item: Item, numberOfTimes: Int) -> [Item] { var result = [Item]() for _ in 0..         你可以创建泛型类型的函数、方法、类、枚举类以及结构体。 // 对 Swift 标准库中的可选值类型进行重新定义实现 enum OptionalValue { case none case some(Wrapped) } var possibleInteger: OptionalValue = .none possibleInteger = .some(100)         在函数体前用 where 来指定泛型需要满足的条件。比如，需要这个类型实现了具体的一个协议，需要两个类型彼此相同，或者是需要这个类型拥有特定的父类。 func anyCommonElements(_ lhs: T, _ rhs: U) -> Bool where T.Element: Equatable, T.Element == U.Element { for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { return true } } } return false } anyCommonElements([1, 2, 3], [3]) 实践         修改 anyCommonElements(_: _:) 函数来实现一个返回一个数组的函数，这个数组包含了任意两个输入数组的所有共有元素。         与 .. where T: Equatable 这两种写法效果是相同的。 "},"WelcomeToSwift/TranslatorNote.html":{"url":"WelcomeToSwift/TranslatorNote.html","title":"译者注","keywords":"","body":"译者注 "},"LanguageGuide/":{"url":"LanguageGuide/","title":"语法教程","keywords":"","body":"语法教程 "},"LanguageGuide/TheBasics.html":{"url":"LanguageGuide/TheBasics.html","title":"基础内容","keywords":"","body":"基础内容         Swift 是一款应用于 iOS ， macOS ，watchOS 以及 tvOS 应用开发的全新编程语言。即便如此，如果你有一定的 C 语言或 Objective-C 的开发经验，你也会感受到 Swift 的诸多部分都非常熟悉。         对于所有 C、Objective-C 语言中的基本类型，Swift 都提供了自己独立的实现版本。比如说，适用于整数型的 Int、适用于浮点数类型的 Double 和 Float、适用于布尔值类型的 Bool 以及适用于文本数据类型的 String。 Swift 也提供了支持 Array、Set 以及 Dictionary 三种集合类型更加强大的实现版本，这部分内容可以参考 集合类型。         与 C 语言一样， Swift 也使用一个可通过标识符名字来引用的变量来存储数值。 Swift 也针对那些数值不可更改的变量（也就是常量）创建了很多附带的特性，并且这使得它比 C 语言中的常量更加强大。当你需要使用那些无需更改的数值时，使用 Swift 中的常量可以让代码更加安全、逻辑更加清晰。         除了熟悉的数据类型外， Swift 还提供了 Objective-C 当中没有的高级数据类型，比如元组。元组可以让你创建及传递一组数值。你可以很自然地使用元组来让函数返回多种类型数值，而这组数值本身就像是一种混合的数值类型。         Swift 也引入了可选值类型，它可以很好地处理数值缺失的场景。可选值表示，要么 它拥有实际的数值并且这个值就是 x ，要么 根本就没有值 。可选值用起来和 Objective-C 中可能为 nil 的指针很相像，但是它在 Swift 中却不仅仅只适用于类。它不仅比 Objective-C 中的 nil 指针更加安全以及拥有更好的可读性，它本身也是 Swift 诸多强大特性的核心。         Swift 是一门 类型安全 的语言，这也就表明它可以帮助你清晰地确定你代码中使用数据的类型。如果你代码中需要使用 String 类型的值，那么类型安全就可以保证你不会错误地传递给它一个 Int 值。同样地，类型安全也确保你不会错误地给一个非可选值的 String 变量赋予一个 String 可选值。类型安全使得你在开发过程中可以尽早地暴露并解决错误。 常量与变量         常量与变量通常与一个拥有指定类型（比如数值 10 以及字符串 \"Hello\"）的命名（比如 maximumNumberOfLoginAttempts 以及 welcomeMessage ）相关联。对于 常量 而言，它的值一旦被设定就不可更改，而 变量 的值却可以在后面继续被修改。 常量与变量的声明         在使用常量与变量之前，必须先对它们进行声明。对于常量，使用 let 关键字来声明，而对于变量，则使用 var 关键字来进行声明。可以通过一个例子来理解如何使用常量与变量来记录用户尝试登录的次数： let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0         对于这段代码，它的涵义就可以理解为：         “声明一个名为 maximumNumberOfLoginAttempts 的常量并为其赋予初始值 10 。然后声明一个名为 currentLoginAttempt 的变量并为其赋予初始值 0”。         在这个示例中，将允许尝试登录的最大次数声明为一个常量是因为这个值是永远不会变的。而将当前尝试登录的次数声明为一个变量是因为在每次登录失败时都要增加这个尝试登录次数。         你也可以通过逗号分隔来实现一行内声明多个变量或常量： var x = 0.0, y = 0.0, z = 0.0 说明         如果记录的一个数值永远不会被修改，就使用 let 关键字来将其声明为一个常量。只对那些需要被修改的数值声明为变量。 类型声明         当声明一个常量（或变量）时，你也可以显式提供一个 类型声明 来更清楚地说明这个常量（或变量）可以存储的值的类型。只需要在常量（变量）名称后面跟一个冒号、空格以及数值类型名即可： var welcomeMessage: String         此处声明中分号的涵义可以认为是 “ ... 的类型是 ... ”，所以这行代码就可以理解为：“声明一个名为 welcomeMessage 的变量，它的类型是 String 类型”。         “类型是 String 类型”，指的是 “它可以存储任意 String 类型的值”。可以把它理解为可以被存储的“某物的类型”（或“某物的种类”）。         此时的 welcomeMessage 变量就可以被赋予任意字符串的值而不会发生错误： welcomeMessage = \"Hello\"         你也可以在一行内声明多个拥有相同类型的变量，仅需要用逗号将它们分隔，并在最后一个变量名后指定类型声明： var red, green, blue: Double 说明         在实际练习过程中，几乎不会需要显式进行类型声明。如果在定义常量（或变量）时提供了初始值，那么 Swift 就几乎总是可以通过初始值来推导出变量（或常量）的类型，可详见 类型安全与类型推导。在上面 welcomeMessage 的例子中，由于没有为它指定初始值，所以就无法通过初始值来推导它的类型，进而就需要使用类型声明来显式指定它的类型。 为常量与变量命名         可以使用包括 Unicode 编码在内的几乎所有字符来为常量与变量命名： let π = 3.14159 let 你好 = \"你好世界\" let 🐶🐮 = \"dogcow\"         常量名（与变量名）不能包含空格符、数学符号、箭头、 Unicode 专用标量值，或划线、方框绘制的字符。命名的起始部分不能是数字，而其他位置则可以使用数字。         一旦你已经为一个常量（或变量）声明了具体类型，那么你就不能再用相同的命名重复对其声明，也不能改变它所能存储的数值类型。当然，你不能让变量变为常量，也不能让常量变成一个变量。 说明         如果你想使用与 Swift 关键字相同的标识符来为常量（或变量）命名，那么你可以在命名两侧加反引号（ ` ）来达到目的。但是，除非你别无选择，否则务必不要使用与关键字相同的命名。         对于一个变量，可以使用适当类型的新值来为其赋值。举个例子， friendlyWelcome 的值就从 \"Hello\" 变成了 \"Bonjour!\" 。 var friendlyWelcome = \"Hello!\" friendlyWelcome = \"Bonjour!\" // friendlyWelcome 现在的值已经是 \"Bonjour!\"         与变量不同，常量的数值在确定后就不可再更改。否则编译时修改常量数值的代码将会报错： let languageName = \"Swift\" languageName = \"Swift++\" // 编译时报错： languageName 不可被更改 打印常量与变量         使用 print(_:separator:terminator:) 函数来打印常量（或变量）的当前值。 print(friendlyWelcome) // 打印出 \"Bonjour!\"         print(_:separator:terminator:) 函数是一个全局的函数，它可以将若干个数值打印输出到合适的输出流。在 Xcode 中， print(_:separator:terminator:) 函数就会把输出内容打印到 Xcode 的控制台面板上。 separator 和 terminator 参数都拥有默认值，所以当你调用这个函数时可以忽略它们。默认情况下，函数打印完一行内容会输出换行，如果不想这样，可以为 terminator 参数赋予一个空字符串—— print(someValue, terminator: \"\") 。关于参数的默认值，详见 参数默认值 。         Swift 支持 字符串插值 —— 在字符串中使用常量名（变量名）来作为占位符，来插入这些变量当前的实际值，只需要在常量名（变量名）两侧用小括号界定，并在左侧小括号前添加一个反斜杠即可： print(\"The current value of friendlyWelcome is \\(friendlyWelcome)\") // 打印出 \"The current value of friendlyWelcome is Bonjour!\" 说明         关于字符串插值的所有可用的选项，详见 字符串插值 。 注释         注释表示那些代码中一定不会执行的文本，它们可用于说明以及备忘。当编译时，注释就会被 Swift 忽略掉。         Swift 中的注释与 C 当中的注释非常相像。比如在行首使用两个斜杠（//），就表示这一行内容是一行注释： // 这是一行注释         而对于多行注释，使用斜杠与星号组合（/*）表示注释开始，使用星号与斜杠组合（*/）表示注释结束： /* 这也是一行注释 但是可以写在多行 */         与 C 的多行注释不同，Swift 支持多行注释的嵌套。比如，在第一个多行注释块中，又写了第二个注释块，那么对于注释结束标识来说，先结束的是第二个注释块，再结束的才是第一个注释块： /* 这是第一个多行注释块的开始 /* 这是第二个，也是嵌套的注释块 */ 这是第一个多行注释块的结束 */         有了嵌套的多行注释，就可以使得注释掉多行代码变得更加简单便捷，即使注释的代码已经包含了多行注释。 分号         与很多编程语言不同，Swift 无需在每行代码末尾添加分号（;）。当然，如果显式添加也是允许的。但如果想在一行代码中书写多个独立的语句，那分号就是必不可少的： let cat = \"🐱\"; print(cat) // 打印出 \"🐱\" 整数         整数 是不包括小数部分的数值，比如 42 和 -23。整数要么是有符号的（正数、零或负数），要么是无符号的（正数或零）。         Swift 提供 8 位、16 位、32 位以及 64 位几种形式的有符号整数和无符号整数。这些整数类型的标识符与 C 保持一致，所以 8 位无符号整数的类型就是 UInt8，而 32 位有符号整数的类型就是 Int32。与 Swift中所有类型一样，这些整数类型的名字都是首字母大写的。 整数范围         通过每种整数类型的 min 和 max 属性可以获取它们可表示范围的最小值与最大值： let minValue = UInt8.min // minValue 的值是 0，并且它的类型是 UInt8 let maxValue = UInt8.max // maxValue 的值是 255，并且它的类型是 UInt8         这些属性值也是相应位数大小的数值（比如上述示例的 UInt8），因此也就可以在表达式中与其他相同类型的值一通使用。 Int 类型         在大多情况下，你无需精确地确定代码中的一个整数类型。Swift 提供了一个附加的整数类型：Int，它的位数大小与当前所在平台环境的原生字大小保持一致。 在 32 位平台，Int 与 Int32 拥有相同的位数大小。 在 64 位平台，Int 与 Int64 拥有相同的位数大小。         除非你很明确你需要使用特定大小的整数类型，否则保持使用 Int 来表示代码中的整数。这样有利于增强代码的一致性与可移植性。即使在 32 位平台中，Int 支持存储的范围也是从 -2,147,483,648 到 2,147,483,647 的，这对于很多整数范围来说都已经足够了。 UInt 类型         类似地，Swift 也提供了与当前平台环境原生字长一致的无符号数类型：UInt： 在 32 位平台，UInt 与 UInt32 拥有相同的位数大小。 在 64 位平台，UInt 与 UInt64 拥有相同的位数大小。 说明         当且仅当确实需要与平台原生字长保持一致的无符号整数类型时才使用 UInt 类型。如果不是这种情况，Int 更被推荐使用，尽管你很明确要存储的数值是一个非负数。对于整数类型保持使用 Int 可以增强代码的可移植性，避免了需要在不同数值类型间转换，并且满足整数类型推导，这部分内容详见 类型安全与类型推导。 浮点数         浮点数 是拥有小数部分的数值，比如 3.14159，0.1 以及 -273.15。         浮点数类型可以表示比整数类型更大范围的数值，并且它可以存储的数值也远比 Int 类型数值更大（或更小）。Swift 提供了两种有符号的浮点数类型： Double 表示 64 位的浮点数。 Float 表示 32 位的浮点数。 说明         Double 拥有至少 15 位（十进制）的精度，而 Float 拥有至少 6 位（十进制）的精度。具体使用哪一种类型，取决于你所需场景中数值的性质与范围。如果两种类型都适用，首选 Double。 类型安全与类型推导         Swift 是一门 类型安全 的编程语言。类型安全的语言可以保证代码中数值的类型是清晰确定的。比如代码中需要一个 String 类型的值，那么就不允许传一个 Int 类型的值。         得益于 Swift 的类型安全，它可以在编译代码时执行类型检查，并将不匹配的数据类型作为编译报错标识出来。这也使得可以在开发阶段可以尽早地发现与修复问题。         类型检查可以避免使用多类型数值的诸多错误。然而，这并不代表在声明每个常量或变量时需要显式明确指定它们的类型。当没有明确指定数值的类型时，Swift 会使用 类型推导 来确定数值的合适数据类型。类型推导使得编译器可以在编译时仅需根据代码中的数值类型，自动推断出相应表达式的数据类型。         也正是得益于类型推导，相较于 C 和 Objective-C 语言，Swift 的变量声明代码少得多。常量与变量依然拥有明确的数据类型，但是明确指定它们类型的工作已经由编译器做好了。         当声明一个拥有初始值的常量（或变量）时，类型推导就变得格外有用。这种情况通常是指通过一个 字面数值（或文本） 来声明并赋值给一个常量（或变量）。（字面值指的就是代码中直接表现出来的数值，比如下面示例代码中的 42 以及 3.14159）。         举例来说，在未声明一个常量的类型的情况下，将一个字面值 42 赋值给它，Swift 就会推导出这个常量的类型应当是 Int，因为它的初始数值就如同一个整数： let meaningOfLife = 42 // meaningOfLife 被推导为整数类型         类似地，如果不指定一个初始字面值为浮点数值的变量类型，那么 Swift 会将其推导为 Double 类型： let pi = 3.14159 // pi 被推导为双精度浮点数（Double 类型）         值得一提的是，Swift 总是会使用 Double（而非 Float）类型来作为浮点字面值的类型推导结果。         如果是一个整数与浮点数字面值的加法表达式，那么表达式结果的数值类型也会推导为 Double： let anotherPi = 3 + 0.14159 // anotherPi 也被推导为双精度浮点数（Double 类型）         字面值 3 没有显式确定的类型，所以表达式中的浮点字面值使得 Double 作为推导结果更加合适。 数值型字面值         数值型字面值通常可以写作以下形式： 没有任何前缀的 十进制 字面值 使用 0b 作为前缀的 二进制 字面值 使用 0o 作为前缀的 八进制 字面值 使用 0x 作为前缀的 十六进制 字面值         举例来说，十进制字面值 17 可以写作： let decimalInteger = 17 let binaryInteger = 0b10001 // 二进制的 17 let octalInteger = 0o21 // 八进制的 17 let hexadecimalInteger = 0x11 // 十六进制的 17         浮点数字面值可以是十进制（无前缀），或十六进制（前缀为 0x）。它们都必须在小数点的两边拥有数值（或十六进制字符）。十进制浮点数字面值也可以选择性地加上 指数，指数使用大写或小写的 e 来表示；而十六进制字面值则必须有一个指数，此时的指数使用大写或小写的 p 来表示。         对于指数为 exp 的十进制数值，基数需要乘以 10exp： 1.25e2 表示 1.25 x 102，或者 125.0。 1.25e-2 表示 1.25 x 10-2，或者 0.0125。         对于指数为 exp 的十六进制数值，基数需要乘以 2exp： 0xFp2 表示 15 x 22，或者 60.0。 0xFp-2 表示 15 x 2-2，或者 3.75。         以下浮点数字面值均表示十进制数值 12.1875： let decimalDouble = 12.1875 let exponentDouble = 1.21875e1 let hexadecimalDouble = 0xC.3p0         数值型字面值也可以包含一些附加的格式化字符来提高它们的易读性。无论是整数还是浮点数，都可以填充额外的零以及下划线来提高可读性。任何用于格式化的字符都不会影响到字面值所表示的实际数值： let paddedDouble = 000123.456 let oneMillion = 1_000_000 let justOverOneMillion = 1_000_000.000_000_1 数值类型间转换         在编码时，对于所有常见的整数需求场景，尽管明确所需数值是一个非负数，都使用 Int 类型。在任何场景下都使用默认的整数类型，就意味着整数类型的常量与变量都可以在代码中快速地转换并且可以很好地匹配整数型字面值。         仅当手头的任务确实需要使用其他类型的整数时才使用，此时可能是为了适配外部源码的固定数值大小、或是为了性能、内存使用以及其他的必要优化。这些场景下使用特定大小的类型可以帮助捕获意外的数值溢出，以及隐式地记录数据本身的特性。 整数间转换         对于不同的数值类型来说，它们所能存储常量（或变量）数值范围也是不同的。Int8 类型的常量（或变量）能存储数值的范围是 -128 到 127，而 UInt8 的常量（或变量）所能存储的范围是 0 到 255。当指定数值不在数值类型所能存储的范围内时，就会产生一个编译期报错： let cannotBeNegative: UInt8 = -1 // UInt8 类型不能存储一个负数，所以这里会报错 let tooBig: Int8 = Int8.max + 1 // Int8 不能存储一个比它所能表示的最大值还要大的数值，所以这里也会报错         由于不同的数值类型所能存储的数值范围也不同，所以必须要根据实际情况来确定数值类型转换。这种确定性的方法避免了隐式类型转换的错误，并且可以让代码中类型转换的意图更加清晰。         为了将一个数值的类型转换为另一种类型，你需要使用现有的这个数值来初始化一个新的目标类型数值。在下面的例子中，常量 twoThousand 的类型是 UInt16，而常量 one 的类型是 UInt8。由于它们的类型不同，所以它们并不能直接相加。取而代之，示例中使用 UInt16(one) 来创建一个拥有 one 实际值的新的 UInt16 类型数值，并且用这个值来取代原来的数值： let twoThousand: UInt16 = 2_000 let one: UInt8 = 1 let twoThousandAndOne = twoThousand + UInt16(one)         此时加法表达式两边都是 UInt16 类型数值了，所以加法操作就被允许了。由于计算结果常量（twoThousand）是两个 UInt16 类型数值加法计算的结果，所以它的类型也被推导为 UInt16。         SomeType(ofInitialValue) 是使用一个初始值来调用一个 Swift 类构造器的默认方式。正是在这种场景下，UInt16 类型拥有一个接受 UInt8 类型数值的构造器，所以可以使用一个现有的 UInt8 类型数值来调用构造器创建一个新的 UInt16 类型数值。然而，并不是任意类型都能达到这样的效果，这取决于 UInt16 提供哪种类型的构造器。扩展现有类型来提供可接受新类型（甚至是自定义的一个类型）的构造器，详情可参考 扩展。 整数与浮点数间转换         整数与浮点数之间的数值类型转换必须显式进行： let three = 3 let pointOneFourOneFiveNine = 0.14159 let pi = Double(three) + pointOneFourOneFiveNine // pi 等于 3.14159，并且它的类型被推导为 Double         这里，常量 three 的数值被用于创建一个类型为 Double 的新值，所以加法表达式两侧数值是相同类型了。如果此处没有这个类型转换，那么加法操作也是不允许执行的。         浮点类型转换为整数类型的操作也必须是显式的。可以使用一个 Double 类型或 Float 类型的数值来初始化一个整数： let integerPi = Int(pi) // integerPi 等于 3，并且它的类型被推导为 Int         这种方式下，用于初始化整数的浮点数会被截断。也就是说，4.751 变成 4，而 -3.9 变成 -3。 说明         数值型常量及变量的计算规则与数值型字面值的规则并不相同。字面值 3 可以与字面值 0.14159 直接相加，是因为数值型字面值本身并没有明确的类型。它们的类型仅在编译器处理到时才会被推导确定。 "},"LanguageReference/":{"url":"LanguageReference/","title":"参考引用","keywords":"","body":"参考引用 "},"RevisionHistory/":{"url":"RevisionHistory/","title":"修订历史","keywords":"","body":"修订历史 "}}