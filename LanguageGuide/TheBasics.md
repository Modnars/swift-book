# 基础内容

&#160; &#160; &#160; &#160; Swift 是一款应用于 iOS ， macOS ，watchOS 以及 tvOS 应用开发的全新编程语言。即便如此，如果你有一定的 C 语言或 Objective-C 的开发经验，你也会对 Swift 的诸多部分都感觉非常熟悉。

&#160; &#160; &#160; &#160; 对于所有 C 语言、Objective-C 语言中的基本类型，Swift 都提供了自己独立的实现版本。比如说，适用于整数型的 `Int`、适用于浮点数类型的 `Double` 和 `Float`、适用于布尔值类型的 `Bool` 以及适用于文本数据类型的 `String`。 Swift 也提供了支持 `Array`、`Set` 以及 `Dictionary` 三种集合类型更加强大的实现版本，这部分内容可以参考 [集合类型](./CollectionTypes.md)。

&#160; &#160; &#160; &#160; 与 C 语言一样， Swift 也使用一个可通过标识符名字来引用的变量来存储数值。 Swift 也针对那些数值不可更改的变量（也就是常量）创建了很多附带的特性，并且这使得它比 C 语言中的常量更加强大。当你需要使用那些无需更改的数值时，使用 Swift 中的常量可以让代码更加安全、逻辑更加清晰。

&#160; &#160; &#160; &#160; 除了熟悉的数据类型外， Swift 还提供了 Objective-C 当中没有的高级数据类型，比如元组。元组可以让你创建及传递一组数值。你可以很自然地使用元组来让函数返回多种类型数值，而这组数值本身就像是一种混合的数值类型。

&#160; &#160; &#160; &#160; Swift 也引入了可选值类型，它可以很好地处理数值缺失的场景。可选值表示，要么 **它拥有实际的数值并且这个值就是 x** ，要么 **根本就没有值** 。可选值用起来和 Objective-C 中可能为 `nil` 的指针很相像，但是它在 Swift 中却不仅仅只适用于类。它不仅比 Objective-C 中的 `nil` 指针更加安全以及拥有更好的可读性，它本身也是 Swift 诸多强大特性的核心。

&#160; &#160; &#160; &#160; Swift 是一门 **类型安全** 的语言，这也就表明它可以帮助你清晰地确定你代码中使用数据的类型。如果你代码中需要使用 `String` 类型的值，那么类型安全就可以保证你不会错误地传递给它一个 `Int` 值。同样地，类型安全也确保你不会错误地给一个非可选值的 `String` 变量赋予一个 `String` 可选值。类型安全使得你在开发过程中可以尽早地暴露并解决错误。

## 常量与变量

&#160; &#160; &#160; &#160; 常量与变量通常与一个拥有指定类型（比如数值 `10` 以及字符串 `"Hello"`）的命名（比如 `maximumNumberOfLoginAttempts` 以及 `welcomeMessage` ）相关联。对于 **常量** 而言，它的值一旦被设定就不可更改，而 **变量** 的值却可以在后面继续被修改。

### 常量与变量的声明

&#160; &#160; &#160; &#160; 在使用常量与变量之前，必须先对它们进行声明。对于常量，使用 `let` 关键字来声明，而对于变量，则使用 `var` 关键字来进行声明。可以通过一个例子来理解如何使用常量与变量来记录用户尝试登录的次数：

```swift
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
```

&#160; &#160; &#160; &#160; 对于这段代码，它的涵义就可以理解为：

&#160; &#160; &#160; &#160; “声明一个名为 `maximumNumberOfLoginAttempts` 的常量并为其赋予初始值 `10` 。然后声明一个名为 `currentLoginAttempt` 的变量并为其赋予初始值 `0`”。

&#160; &#160; &#160; &#160; 在这个示例中，将允许尝试登录的最大次数声明为一个常量是因为这个值是永远不会变的。而将当前尝试登录的次数声明为一个变量是因为在每次登录失败时都要增加这个尝试登录次数。

&#160; &#160; &#160; &#160; 你也可以通过逗号分隔来实现一行内声明多个变量或常量：

```swift
var x = 0.0, y = 0.0, z = 0.0
```

> _**说明**_
>
> &#160; &#160; &#160; &#160; 如果记录的一个数值永远不会被修改，就使用 `let` 关键字来将其声明为一个常量。只对那些需要被修改的数值声明为变量。

### 类型声明

&#160; &#160; &#160; &#160; 当声明一个常量（或变量）时，你也可以显式提供一个 **类型声明** 来更清楚地说明这个常量（或变量）可以存储的值的类型。只需要在常量（变量）名称后面跟一个冒号、空格以及数值类型名即可：

```swift
var welcomeMessage: String
```

&#160; &#160; &#160; &#160; 此处声明中分号的涵义可以认为是 “ ... 的类型是 ... ”，所以这行代码就可以理解为：“声明一个名为 `welcomeMessage` 的变量，它的类型是 `String` 类型”。

&#160; &#160; &#160; &#160; “类型是 `String` 类型”，指的是 “它可以存储任意 `String` 类型的值”。可以把它理解为可以被存储的“某物的类型”（或“某物的种类”）。

&#160; &#160; &#160; &#160; 此时的 `welcomeMessage` 变量就可以被赋予任意字符串的值而不会发生错误：

```swift
welcomeMessage = "Hello"
```

&#160; &#160; &#160; &#160; 你也可以在一行内声明多个拥有相同类型的变量，仅需要用逗号将它们分隔，并在最后一个变量名后指定类型声明：

```swift
var red, green, blue: Double
```

> _**说明**_
>
> &#160; &#160; &#160; &#160; 在实际练习过程中，几乎不会需要显式进行类型声明。如果在定义常量（或变量）时提供了初始值，那么 Swift 就几乎总是可以通过初始值来推导出变量（或常量）的类型，可详见 [类型安全与类型推导](#类型安全与类型推导)。在上面 `welcomeMessage` 的例子中，由于没有为它指定初始值，所以就无法通过初始值来推导它的类型，进而就需要使用类型声明来显式指定它的类型。

### 为常量与变量命名

&#160; &#160; &#160; &#160; 可以使用包括 Unicode 编码在内的几乎所有字符来为常量与变量命名：

```swift
let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
```

&#160; &#160; &#160; &#160; 常量名（与变量名）不能包含空格符、数学符号、箭头、 Unicode 专用标量值，或划线、方框绘制的字符。命名的起始部分不能是数字，而其他位置则可以使用数字。

&#160; &#160; &#160; &#160; 一旦你已经为一个常量（或变量）声明了具体类型，那么你就不能再用相同的命名重复对其声明，也不能改变它所能存储的数值类型。当然，你不能让变量变为常量，也不能让常量变成一个变量。

> _**说明**_
>
> &#160; &#160; &#160; &#160; 如果你想使用与 Swift 关键字相同的标识符来为常量（或变量）命名，那么你可以在命名两侧加反引号（ ` ）来达到目的。但是，除非你别无选择，否则务必不要使用与关键字相同的命名。

&#160; &#160; &#160; &#160; 对于一个变量，可以使用适当类型的新值来为其赋值。举个例子， `friendlyWelcome` 的值就从 `"Hello"` 变成了 `"Bonjour!"` 。

```swift
var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome 现在的值已经是 "Bonjour!"
```

&#160; &#160; &#160; &#160; 与变量不同，常量的数值在确定后就不可再更改。否则编译时修改常量数值的代码将会报错：

```swift
let languageName = "Swift"
languageName = "Swift++"
// 编译时报错： languageName 不可被更改
```

### 打印常量与变量

&#160; &#160; &#160; &#160; 使用 `print(_:separator:terminator:)` 函数来打印常量（或变量）的当前值。

```swift
print(friendlyWelcome)
// 打印出 "Bonjour!"
```

&#160; &#160; &#160; &#160; `print(_:separator:terminator:)` 函数是一个全局的函数，它可以将若干个数值打印输出到合适的输出流。在 Xcode 中， `print(_:separator:terminator:)` 函数就会把输出内容打印到 Xcode 的控制台面板上。 `separator` 和 `terminator` 参数都拥有默认值，所以当你调用这个函数时可以忽略它们。默认情况下，函数打印完一行内容会输出换行，如果不想这样，可以为 `terminator` 参数赋予一个空字符串—— `print(someValue, terminator: "")` 。关于参数的默认值，详见 [参数默认值](#参数默认值) 。

&#160; &#160; &#160; &#160; Swift 支持 **字符串插值** —— 在字符串中使用常量名（变量名）来作为占位符，来插入这些变量当前的实际值，只需要在常量名（变量名）两侧用小括号界定，并在左侧小括号前添加一个反斜杠即可：

```swift
print("The current value of friendlyWelcome is \(friendlyWelcome)")
// 打印出 "The current value of friendlyWelcome is Bonjour!"
```

> _**说明**_
>
> &#160; &#160; &#160; &#160; 关于字符串插值的所有可用的选项，详见 [字符串插值](#字符串插值) 。

## 注释

&#160; &#160; &#160; &#160; 注释表示那些代码中一定不会执行的文本，它们可用于说明以及备忘。当编译时，注释就会被 Swift 忽略掉。

&#160; &#160; &#160; &#160; Swift 中的注释与 C 当中的注释非常相像。比如在行首使用两个斜杠（`//`），就表示这一行内容是一行注释：

```swift
// 这是一行注释
```

&#160; &#160; &#160; &#160; 而对于多行注释，使用斜杠与星号组合（`/*`）表示注释开始，使用星号与斜杠组合（`*/`）表示注释结束：

```swift
/* 这也是一行注释
但是可以写在多行 */
```

&#160; &#160; &#160; &#160; 与 C 的多行注释不同，Swift 支持多行注释的嵌套。比如，在第一个多行注释块中，又写了第二个注释块，那么对于注释结束标识来说，先结束的是第二个注释块，再结束的才是第一个注释块：

```swift
/* 这是第一个多行注释块的开始
 /* 这是第二个，也是嵌套的注释块 */
这是第一个多行注释块的结束 */
```

&#160; &#160; &#160; &#160; 有了嵌套的多行注释，就可以使得注释掉多行代码变得更加简单便捷，即使注释的代码已经包含了多行注释。

## 分号

&#160; &#160; &#160; &#160; 与很多编程语言不同，Swift 无需在每行代码末尾添加分号（;）。当然，如果显式添加也是允许的。但如果想在一行代码中书写多个独立的语句，那分号就是必不可少的：

```swift
let cat = "🐱"; print(cat)
// 打印出 "🐱"
```

## 整数

&#160; &#160; &#160; &#160; **整数** 是不包括小数部分的数值，比如 `42` 和 `-23`。整数要么是有符号的（正数、零或负数），要么是无符号的（正数或零）。

&#160; &#160; &#160; &#160; Swift 提供 8 位、16 位、32 位以及 64 位几种形式的有符号整数和无符号整数。这些整数类型的标识符与 C 保持一致，所以 8 位无符号整数的类型就是 `UInt8`，而 32 位有符号整数的类型就是 `Int32`。与 Swift中所有类型一样，这些整数类型的名字都是首字母大写的。

### 整数范围

&#160; &#160; &#160; &#160; 通过每种整数类型的 `min` 和 `max` 属性可以获取它们可表示范围的最小值与最大值：

```swift
let minValue = UInt8.min  // minValue 的值是 0，并且它的类型是 UInt8
let maxValue = UInt8.max  // maxValue 的值是 255，并且它的类型是 UInt8
```

&#160; &#160; &#160; &#160; 这些属性值也是相应位数大小的数值（比如上述示例的 `UInt8`），因此也就可以在表达式中与其他相同类型的值一通使用。

### Int 类型

&#160; &#160; &#160; &#160; 在大多情况下，你无需精确地确定代码中的一个整数类型。Swift 提供了一个附加的整数类型：Int，它的位数大小与当前所在平台环境的原生字大小保持一致。

- 在 32 位平台，`Int` 与 `Int32` 拥有相同的位数大小。

- 在 64 位平台，`Int` 与 `Int64` 拥有相同的位数大小。

&#160; &#160; &#160; &#160; 除非你很明确你需要使用特定大小的整数类型，否则保持使用 `Int` 来表示代码中的整数。这样有利于增强代码的一致性与可移植性。即使在 32 位平台中，`Int` 支持存储的范围也是从 `-2,147,483,648` 到 `2,147,483,647` 的，这对于很多整数范围来说都已经足够了。

### UInt 类型

&#160; &#160; &#160; &#160; 类似地，Swift 也提供了与当前平台环境原生字长一致的无符号数类型：UInt：

- 在 32 位平台，`UInt` 与 `UInt32` 拥有相同的位数大小。

- 在 64 位平台，`UInt` 与 `UInt64` 拥有相同的位数大小。

> _**说明**_
>
> &#160; &#160; &#160; &#160; 当且仅当确实需要与平台原生字长保持一致的无符号整数类型时才使用 `UInt` 类型。如果不是这种情况，`Int` 更被推荐使用，尽管你很明确要存储的数值是一个非负数。对于整数类型保持使用 `Int` 可以增强代码的可移植性，避免了需要在不同数值类型间转换，并且满足整数类型推导，这部分内容详见 [类型安全与类型推导](#类型安全与类型推导)。

## 浮点数

&#160; &#160; &#160; &#160; **浮点数** 是拥有小数部分的数值，比如 `3.14159`，`0.1` 以及 `-273.15`。

&#160; &#160; &#160; &#160; 浮点数类型可以表示比整数类型更大范围的数值，并且它可以存储的数值也远比 `Int` 类型数值更大（或更小）。Swift 提供了两种有符号的浮点数类型：

- `Double` 表示 64 位的浮点数。

- `Float` 表示 32 位的浮点数。

> _**说明**_
>
> &#160; &#160; &#160; &#160; `Double` 拥有至少 15 位（十进制）的精度，而 `Float` 拥有至少 6 位（十进制）的精度。具体使用哪一种类型，取决于你所需场景中数值的性质与范围。如果两种类型都适用，首选 `Double`。

## 类型安全与类型推导

&#160; &#160; &#160; &#160; Swift 是一门 **类型安全** 的编程语言。类型安全的语言可以保证代码中数值的类型是清晰确定的。比如代码中需要一个 `String` 类型的值，那么就不允许传一个 `Int` 类型的值。

&#160; &#160; &#160; &#160; 得益于 Swift 的类型安全，它可以在编译代码时执行类型检查，并将不匹配的数据类型作为编译报错标识出来。这也使得可以在开发阶段可以尽早地发现与修复问题。

&#160; &#160; &#160; &#160; 类型检查可以避免使用多类型数值的诸多错误。然而，这并不代表在声明每个常量或变量时需要显式明确指定它们的类型。当没有明确指定数值的类型时，Swift 会使用 **类型推导** 来确定数值的合适数据类型。类型推导使得编译器可以在编译时仅需根据代码中的数值类型，自动推断出相应表达式的数据类型。

&#160; &#160; &#160; &#160; 也正是得益于类型推导，相较于 C 和 Objective-C 语言，Swift 的变量声明代码少得多。常量与变量依然拥有明确的数据类型，但是明确指定它们类型的工作已经由编译器做好了。

&#160; &#160; &#160; &#160; 当声明一个拥有初始值的常量（或变量）时，类型推导就变得格外有用。这种情况通常是指通过一个 **字面数值（或文本）** 来声明并赋值给一个常量（或变量）。（字面值指的就是代码中直接表现出来的数值，比如下面示例代码中的 `42` 以及 `3.14159`）。

&#160; &#160; &#160; &#160; 举例来说，在未声明一个常量的类型的情况下，将一个字面值 `42` 赋值给它，Swift 就会推导出这个常量的类型应当是 `Int`，因为它的初始数值就如同一个整数：

```swift
let meaningOfLife = 42
// meaningOfLife 被推导为整数类型
```

&#160; &#160; &#160; &#160; 类似地，如果不指定一个初始字面值为浮点数值的变量类型，那么 Swift 会将其推导为 `Double` 类型：

```swift
let pi = 3.14159
// pi 被推导为双精度浮点数（Double 类型）
```

&#160; &#160; &#160; &#160; 值得一提的是，Swift 总是会使用 `Double`（而非 `Float`）类型来作为浮点字面值的类型推导结果。

&#160; &#160; &#160; &#160; 如果是一个整数与浮点数字面值的加法表达式，那么表达式结果的数值类型也会推导为 `Double`：

```swift
let anotherPi = 3 + 0.14159
// anotherPi 也被推导为双精度浮点数（Double 类型）
```

&#160; &#160; &#160; &#160; 字面值 `3` 没有显式确定的类型，所以表达式中的浮点字面值使得 `Double` 作为推导结果更加合适。

## 数值型字面值

&#160; &#160; &#160; &#160; 数值型字面值通常可以写作以下形式：

- 没有任何前缀的 **十进制** 字面值
- 使用 `0b` 作为前缀的 **二进制** 字面值
- 使用 `0o` 作为前缀的 **八进制** 字面值
- 使用 `0x` 作为前缀的 **十六进制** 字面值

&#160; &#160; &#160; &#160; 举例来说，十进制字面值 `17` 可以写作：

```swift
let decimalInteger = 17
let binaryInteger = 0b10001       // 二进制的 17
let octalInteger = 0o21           // 八进制的 17
let hexadecimalInteger = 0x11     // 十六进制的 17
```

&#160; &#160; &#160; &#160; 浮点数字面值可以是十进制（无前缀），或十六进制（前缀为 `0x`）。它们都必须在小数点的两边拥有数值（或十六进制字符）。十进制浮点数字面值也可以选择性地加上 **指数**，指数使用大写或小写的 `e` 来表示；而十六进制字面值则必须有一个指数，此时的指数使用大写或小写的 `p` 来表示。

&#160; &#160; &#160; &#160; 对于指数为 `exp` 的十进制数值，基数需要乘以 10<sup>exp</sup>：

- `1.25e2` 表示 1.25 x 10<sup>2</sup>，或者 `125.0`。
- `1.25e-2` 表示 1.25 x 10<sup>-2</sup>，或者 `0.0125`。

&#160; &#160; &#160; &#160; 对于指数为 `exp` 的十六进制数值，基数需要乘以 2<sup>exp</sup>：

- `0xFp2` 表示 15 x 2<sup>2</sup>，或者 `60.0`。
- `0xFp-2` 表示 15 x 2<sup>-2</sup>，或者 `3.75`。

&#160; &#160; &#160; &#160; 以下浮点数字面值均表示十进制数值 `12.1875`：

```swift
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
```

&#160; &#160; &#160; &#160; 数值型字面值也可以包含一些附加的格式化字符来提高它们的易读性。无论是整数还是浮点数，都可以填充额外的零以及下划线来提高可读性。任何用于格式化的字符都不会影响到字面值所表示的实际数值：

```swift
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```

## 数值类型间转换

&#160; &#160; &#160; &#160; 在编码时，对于所有常见的整数需求场景，尽管明确所需数值是一个非负数，都使用 `Int` 类型。在任何场景下都使用默认的整数类型，就意味着整数类型的常量与变量都可以在代码中快速地转换并且可以很好地匹配整数型字面值。

&#160; &#160; &#160; &#160; 仅当手头的任务确实需要使用其他类型的整数时才使用，此时可能是为了适配外部源码的固定数值大小、或是为了性能、内存使用以及其他的必要优化。这些场景下使用特定大小的类型可以帮助捕获意外的数值溢出，以及隐式地记录数据本身的特性。

### 整数间转换

&#160; &#160; &#160; &#160; 对于不同的数值类型来说，它们所能存储常量（或变量）数值范围也是不同的。`Int8` 类型的常量（或变量）能存储数值的范围是 `-128` 到 `127`，而 `UInt8` 的常量（或变量）所能存储的范围是 `0` 到 `255`。当指定数值不在数值类型所能存储的范围内时，就会产生一个编译期报错：

```swift
let cannotBeNegative: UInt8 = -1
// UInt8 类型不能存储一个负数，所以这里会报错
let tooBig: Int8 = Int8.max + 1
// Int8 不能存储一个比它所能表示的最大值还要大的数值，所以这里也会报错
```

&#160; &#160; &#160; &#160; 由于不同的数值类型所能存储的数值范围也不同，所以必须要根据实际情况来确定数值类型转换。这种确定性的方法避免了隐式类型转换的错误，并且可以让代码中类型转换的意图更加清晰。

&#160; &#160; &#160; &#160; 为了将一个数值的类型转换为另一种类型，你需要使用现有的这个数值来初始化一个新的目标类型数值。在下面的例子中，常量 `twoThousand` 的类型是 `UInt16`，而常量 `one` 的类型是 `UInt8`。由于它们的类型不同，所以它们并不能直接相加。取而代之，示例中使用 `UInt16(one)` 来创建一个拥有 `one` 实际值的新的 `UInt16` 类型数值，并且用这个值来取代原来的数值：

```swift
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
```

&#160; &#160; &#160; &#160; 此时加法表达式两边都是 `UInt16` 类型数值了，所以加法操作就被允许了。由于计算结果常量（`twoThousand`）是两个 `UInt16` 类型数值加法计算的结果，所以它的类型也被推导为 `UInt16`。

&#160; &#160; &#160; &#160; `SomeType(ofInitialValue)` 是使用一个初始值来调用一个 Swift 类构造器的默认方式。正是在这种场景下，`UInt16` 类型拥有一个接受 `UInt8` 类型数值的构造器，所以可以使用一个现有的 `UInt8` 类型数值来调用构造器创建一个新的 `UInt16` 类型数值。然而，并不是任意类型都能达到这样的效果，这取决于 `UInt16` 提供哪种类型的构造器。扩展现有类型来提供可接受新类型（甚至是自定义的一个类型）的构造器，详情可参考 [扩展](#扩展)。

### 整数与浮点数间转换

&#160; &#160; &#160; &#160; 整数与浮点数之间的数值类型转换必须显式进行：

```swift
let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi 等于 3.14159，并且它的类型被推导为 Double
```

&#160; &#160; &#160; &#160; 这里，常量 `three` 的数值被用于创建一个类型为 `Double` 的新值，所以加法表达式两侧数值是相同类型了。如果此处没有这个类型转换，那么加法操作也是不允许执行的。

&#160; &#160; &#160; &#160; 浮点类型转换为整数类型的操作也必须是显式的。可以使用一个 `Double` 类型或 `Float` 类型的数值来初始化一个整数：

```swift
let integerPi = Int(pi)
// integerPi 等于 3，并且它的类型被推导为 Int
```

&#160; &#160; &#160; &#160; 这种方式下，用于初始化整数的浮点数会被截断。也就是说，`4.751` 变成 `4`，而 `-3.9` 变成 `-3`。

> _**说明**_
>
> &#160; &#160; &#160; &#160; 数值型常量及变量的计算规则与数值型字面值的规则并不相同。字面值 3 可以与字面值 0.14159 直接相加，是因为数值型字面值本身并没有明确的类型。它们的类型仅在编译器处理到时才会被推导确定。

## 类型别名

&#160; &#160; &#160; &#160; **类型别名**能够为已有的类型定义一个可代替使用的名字，你可以使用 `typealias` 关键字来定义一个类型别名。

&#160; &#160; &#160; &#160; 类型别名很适合在一段代码中用于指代一个已有的类型。比如从外部空间采集音频样本时：

```swift
typealias AudioSample = UInt16
```

&#160; &#160; &#160; &#160; 成功定义了一个类型别名后，就可以在任何其他本可以使用原类型的地方，改为使用这个新的命名别名：

```swift
var maxAmplitudeFound = AudioSample.min
// 现在，maxAmplitudeFound 的值是 0
```

&#160; &#160; &#160; &#160; 这里，`AudioSample` 是 `UInt16` 的命名别名。由于它本身只是一个命名别名，那么对于 `AudioSample.min` 的调用，实际就是调用的 `UInt16.min`。结果就是为变量 `maxAmplitudeFound` 赋予了初始值 0。

## 布尔值

&#160; &#160; &#160; &#160; Swift 的**布尔**基本类型，关键字为 `Bool`。由于布尔值只能是真（true）或假（false），所以通常用于表示逻辑值。Swift 也提供了这两个布尔类型的常量值，即 `true` 和 `false`：

```swift
let orangesAreOrange = true
let turnipsAreDelicious = false
```

&#160; &#160; &#160; &#160; 这里使用了布尔类型的字面值常量为 `orangesAreOrange` 和 `turnipsAreDelicious` 赋初值，所以它们的类型被推导为 `Bool` 类型。与之前讲过的 `Int` 及 `Double` 类型一样，使用布尔类型字面值创建的常量（或变量）无需显示地声明其为 `Bool` 类型。即：当使用明确类型的值去初始化常量（或变量）时，类型推导可保持 Swift 代码的简洁性与易读性。

&#160; &#160; &#160; &#160; 对于 `if` 这样的条件语句，布尔值就显得格外重要：

```swift
if turnipsAreDelicious {
    print("Mmm, tasty turnips!")
} else {
    print("Eww, turnips are horrible.")
}
// 打印 “Eww, turnips are horrible.”
```

&#160; &#160; &#160; &#160; 关于条件语句（包括 `if` 语句在内）的细节，可参考 [控制流](./ControlFlow.md) 章节。

&#160; &#160; &#160; &#160; Swift 的类型安全机制会禁止非布尔类型的值隐式转换为 `Bool` 类型。对于这个例子，编译器将会直接报错：

```swift
let i = 1
if i {
    // 这段示例代码不会编译通过，并且会收到编译器的报错。
}
```

&#160; &#160; &#160; &#160; 而这样的示例代码才能通过编译：

```swift
let i = 1
if i == 1 {
    // 这段代码可以成功通过编译
}
```

&#160; &#160; &#160; &#160; `i == 1` 比较（运算操作）的结果是 `Bool` 类型的，这就是上述第二个示例可以通过类型检查的原因。类似 `i == 1` 这样的比较操作，在 [基础运算符](./BasicOperators.md) 章节会有进一步的探讨。

&#160; &#160; &#160; &#160; 正如其他相关示例代码一样，Swift 类型安全可以避免无意的错误，使得代码能够更加清晰地表明其逻辑意图。

## 元组

&#160; &#160; &#160; &#160; **元组类型**是将多种类型组合到一起的类型，元组支持组合任意类型且并不要求这些类型必须一致。

&#160; &#160; &#160; &#160; 在接下来的示例代码中，`(404, "Not Found")` 就是一个描述**HTTP 状态码**的元组类型值。HTTP 状态码是用户访问网页时 Web 服务器返回的特定编码。当访问的页面不存在时，服务器就会返回 `404 Not Found`。

```swift
let http404Error = (404, "Not Found")
// http404Error 的类型是 (Int, String) 元组，它的值是 (404, "Not Found")
```

&#160; &#160; &#160; &#160; `(404, "Not Found")` 元组组合了 `Int` 和 `String` 类型，以此来描述 HTTP 状态码，就可以用一个数值表示具体错误码、用一个字符串描述具体问题。因此，它也可以看作是“`(Int, String)` 元组”的值。

&#160; &#160; &#160; &#160; 元组支持任意数量、任意排列的组合。无论是需要 `(Int, Int, Int)` 类型还是 `(String, Bool)` 类型，元组都可以支持。

&#160; &#160; &#160; &#160; 同时，元组也支持**拆分**，继而可以用以往赋值方式来单独访问其元素：

```swift
let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// 打印“The status code is 404”
print("The status message is \(statusMessage)")
// 打印“The status message is Not Found”
```

&#160; &#160; &#160; &#160; 如果只是需要元组的部分元素值，则可以用下划线作为需要忽略元素的变量名：

```swift
let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// 打印“The status code is 404”
```

&#160; &#160; &#160; &#160; 或者，也可以用从 0 开始的下标来访问元组的单个元素值：

```swift
print("The status code is \(http404Error.0)")
// 打印“The status code is 404”
print("The status message is \(http404Error.1)")
// 打印“The status message is Not Found”
```

&#160; &#160; &#160; &#160; 元组也同样支持在元组创建时为其元素设置名字：

```swift
let http200Status = (statusCode: 200, description: "OK")
```

&#160; &#160; &#160; &#160; 这样一来，就可以直接通过元素名直接访问相应元素了：

```swift
print("The status code is \(http200Status.statusCode)")
// 打印“The status code is 200”
print("The status message is \(http200Status.description)")
// 打印“The status message is OK”
```

&#160; &#160; &#160; &#160; 元组类型经常作为函数的返回值类型。网页检索的函数可以返回 `(Int, String)` 类型的元组来描述检索操作是否成功，相比于返回的单类型值，有着两种不同元素类型的元组可以提供更加丰富有用的信息。关于函数返回值的更多信息，可以参考 [多种返回值型函数](./Functions.md#多种返回值型函数)。

> _**说明**_
>
> &#160; &#160; &#160; &#160; 元组很适用于组合有关联的简单类型，但并不适合用来创建复杂的数据结构。如果数据结构很复杂，用类或结构体来定义（而非元组）则更为合适。关于这部分的更多信息，详见 [结构体与类](./StructuresAndClasses.md) 章节。

## 可选值

&#160; &#160; &#160; &#160; **可选值类型**用于量值[^1]可能不存在的场景。可选值表示：要么量值存在，此时可以通过解包（ _unwrap_ ）的方式来访问相应值；要么量值并不存在。

> _**说明**_
>
> &#160; &#160; &#160; &#160; 在 C 语言和 Objective-C 语言中并不存在可选值的概念。与之表现最相似的，应当是 Objective-C 语言中允许一个返回值类型为对象的函数方法实际返回 `nil`，而 `nil` 本身表示“对象的缺失”。然而——它只适用于对象，并不适用于结构体、C 语言基本类型、枚举类型。对于这些类型，Objective-C 函数方法典型的做法是返回一个特殊值（比如 `NSNotFound`)来表示量值的缺失。这样的做法默认函数方法的调用者知道它会返回一个特殊值并对其有相应测试及校验。而 Swift 的可选值让你知晓任意类型在值可能缺失的情况下，无需再针对性地判断特殊的常量了。

&#160; &#160; &#160; &#160; 举一个在量值可能缺失的场景下使用可选值类型的示例。Swift 的 `Int` 类型拥有一个可以将 `String` 类型转换为 `Int` 类型的构造器。很明显，并非所有的字符串都可以转换为整数，比如 `"123"` 可以转换为数值 `123`，但 `"hello, world"` 则不能（或者说，并没有一种足够显然的转换策略）。

&#160; &#160; &#160; &#160; 下面这段代码展示了如何使用这一构造器将量值从 `String` 类型转换为 `Int` 类型：

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber 的类型被推导为 "Int?" ，也就是“可选Int类型”。
```

&#160; &#160; &#160; &#160; 由于构造器可能执行失败，所以它的返回值类型是**可选的** `Int`，而非 `Int`。可选的 `Int` 写作 `Int?`，而非 `Int`。问号表示量值的内容是可选的，要么确实有 `Int` 类型的值，要么并没有任何值。（注意，它的值不能是 `Bool` 、`String` 这样的其他类型的值。它的值要么是 `Int` 类型的，要么就没有值。）

### nil

&#160; &#160; &#160; &#160; `nil` 可以用于为一些无意义的可选值赋值。

```swift
var serverResponseCode: Int? = 404
// serverResponseCode 有着实际的 Int 值：404
serverResponseCode = nil
// 此时的 serverResponseCode 则没有任何值了
```

> _**说明**_
>
> &#160; &#160; &#160; &#160; 对于非可选值类型的量值，不可以为其赋值 `nil`。如果代码中的逻辑确实存在可能缺失量值的场景，就把该量值声明为相应类型的可选值类型。

&#160; &#160; &#160; &#160; 如果定义了可选值类型的变量而没有为其初始化一个值，那么该变量会默认被置为 `nil`：

```swift
var surveyAnswer: String?
// surveyAnswer 会被自动置为 nil
```

> _**说明**_
>
> &#160; &#160; &#160; &#160; Swift 的 `nil` 与 Objective-C 语言中的 `nil` 并不相同。在 Objective-C 语言中，`nil` 表示一个指向不存在的对象的指针。而在 Swift 中，`nil` 并非是一个指针，而仅表示一个确定类型的值的缺失。**任何**类型的可选值都可以被设置为 `nil`，而非仅适用于对象类型。

### if 语句与强解包

&#160; &#160; &#160; &#160; 在 `if` 语句中，可以将可选值与 `nil` 比较来判断可选值是否实际拥有值。此时可以使用“相等”逻辑判断符（==）或“不等”逻辑判断符（!=）来完成上述比较操作。

&#160; &#160; &#160; &#160; 如果一个可选值拥有具体值，那么它就“不等于”`nil`。

```swift
if convertedNumber != nil {
    print("convertedNumber contains some integer value.")
}
// 打印“convertedNumber contains some integer value.”
```

&#160; &#160; &#160; &#160; 如果明确一个可选值**一定**拥有具体值，就可以在该可选量值名后加叹号（!）来访问它的值。此时的叹号表示：“我明确知道这个可选值一定拥有具体值，可以放心对其解包使用！”。这一操作就是**强解包**：

```swift
if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).")
}
// 打印“convertedNumber has an integer value of 123.”
```

&#160; &#160; &#160; &#160; 关于 `if` 语句的更多内容，可参考 [控制流](./ControlFlow.md) 章节。

> _**说明**_
>
> &#160; &#160; &#160; &#160; 对不存在值的可选值使用 `!` 来强解包会触发一个运行时错误。在使用 `!` 来强解包一个可选值前，请务必确保该可选值拥有 `非 nil` 值。

### 可选值绑定

&#160; &#160; &#160; &#160; **可选值绑定**能确定一个可选值是否拥有真实的值：如果有的话，就会将相应的值转换为一个临时的常量或变量以供使用。可选值绑定与 `if` 和 `while` 语句结合，可以检查条件中的可选值是否拥有真实的值，（如果有的话）可以将这个值赋给一个临时的常量或变量，继而在逻辑体内使用它们。关于 `if` 和 `while` 语句的更多细节，可以参考 [控制流](./ControlFlow.md) 章节。

&#160; &#160; &#160; &#160; 可选值绑定与 `if` 语句结合使用的规则如下：

```swift
if let constantName = someOptional {
    statements
}
```

&#160; &#160; &#160; &#160; 现在，就可以用可选值绑定来替换强解包重写上述 [可选值](#可选值) 章节的 `possibleNumber` 示例代码：

```swift
if let actualNumber = Int(possibleNumber) {
    print("The string \"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("The string \"\(possibleNumber)\" couldn't be converted to an integer")
}
// 打印“The string "123" has an integer value of 123”
```

&#160; &#160; &#160; &#160; 这段代码可以解读为：“如果 `Int(possibleNumber)` 返回值（可选 `Int` 类型）确实拥有真实的值，就将其值赋值给一个名为 `actualNumber` 的新建常量。”

&#160; &#160; &#160; &#160; 如果转换成功，那么常量 `actualNumber` 在 `if` 的第一个条件分支中就可以直接访问使用了，并且它也已经用可选值的真实值初始化完成了，因此也就不必再用 `!` 来解包访问其真实值了。这个示例中，`auctualNumer` 仅被用于打印转换后的结果。

&#160; &#160; &#160; &#160; 如果在访问获取其真实值后无需再引用原来的可选量值，则可以直接用相同的名字来命名新的量值：

```swift
let myNumber = Int(possibleNumber)
// 这里，myNumber 是一个可选 Int 类型量值
if let myNumber = myNumber {
    // 这里，myNumber 是一个非可选类型的整数量值
    print("My number is \(myNumber)")
}
// 打印“My number is 123”
```

&#160; &#160; &#160; &#160; 正如前面的示例，这段代码也会优先检查 `myNumber` 是否拥有真实值。如果有，就将其赋值给名为 `myNumber` 的常量。在 `if` 语句逻辑体内，`myNumber` 均指代这个新的非可选值常量，而在这段逻辑体外，`myNumber` 则指代外层的可选 `Int` 型常量。

&#160; &#160; &#160; &#160; 实际上，这种场景是很常见的，所以此时也可以更精简一些：只需要写出相应需要解包的量值名即可。然后，就可以直接用这个已解包的同名量值。

```swift
if let myNumber {
    print("My number is \(myNumber)")
}
// 打印“My number is 123”
```

&#160; &#160; &#160; &#160; 可选值绑定对于变量也同样支持。如果在上述 `if` 语句逻辑体中需要修改 `myNumber` 的值，那么就可以将可选值绑定写为 `if var myNumber`，这样可选值的真实值就会赋值给这个同名的变量。值得注意的是，此时**在逻辑体内对这个变量的修改，只会在逻辑体内生效，并不会实际修改外层原来的可选值**。

&#160; &#160; &#160; &#160; `if` 语句同样支持多个可选值绑定与布尔条件写在一起，它们彼此间需要用逗号分开。如果其中任意一个可选值绑定的量值为 `nil`，或布尔条件结果为 `false`，那么整个 `if` 语句的条件判断结果就是 `false`。比如，以下两个 `if` 语句是等价的：

```swift
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// 打印“4 < 42 < 100”

if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// 打印“4 < 42 < 100”
```

> _**说明**_
>
> &#160; &#160; &#160; &#160; `if` 语句中通过可选值绑定创建的量值只存在于 `if` 语句逻辑体中。相反，可选值绑定创建的量值在 `guard` 语句之后的代码中依然可用。详情可参考 [及时退出](./ControlFlow.md#及时退出)。

### 隐式解包可选值

&#160; &#160; &#160; &#160; 正如之前提到的，可选值类型就是“可能并没有真实值”的类型。具体地，可以通过 `if` 语句来检查是否具有真实值，而且如果有，就可以进一步通过可选值绑定来获取这个真实值。

&#160; &#160; &#160; &#160; 有时，代码逻辑中可以明确保证一个可选值在赋值后会**一直**拥有真实值，那么此时如果能移除对这个可选值的检查及解包逻辑就变得很有必要，因为本身就已经能保证它一直有着真实值，即访问获取它真实值的操作一定是安全[^2]的。

&#160; &#160; &#160; &#160; 对于这些一直有着真实值的可选值，我们将其定义为**隐式解包可选值**。对于这类隐式解包可选值，可以在定义时用叹号声明（`String!`）取代原来的问号声明（`String?`）。这样一来，就无需每次访问获取时用叹号（强解包），只需声明时用叹号（隐式解包可选值）就可以了。

&#160; &#160; &#160; &#160; 隐式解包可选值适用于那些定义时即可保证拥有真实值、且保证后续会一直拥有真实值的可选值。正如 [无主引用及隐式解包可选值属性](./AutomaticReferenceCounting.md#无主引用及隐式解包可选值属性) 章节所描述的，Swift 中隐式解包可选值最常见的用法就是在类（对象）的初始化过程使用。

&#160; &#160; &#160; &#160; 尽管隐式解包可选值依然是一个普通的可选值，但在访问其真实值时，却又可以像非可选值一样使用，而无需每次访问时都要对其解包。下面这段示例代码展示了字符串可选值和可以像真实 `String` 类型一样访问其值的字符串隐式解包可选值之间的差异：

```swift
let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // 需要一个叹号（执行强解包操作）

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // 无需叹号（访问隐式解包可选值）
```

&#160; &#160; &#160; &#160; 可以看作：隐式解包可选值类型，就是给了普通可选值一种需要时自动执行强解包操作的类型。即 Swift 会优先将其视为一个普通可选值，一旦相应操作不能由可选值类型完成（比如赋值给一个确定的非可选值类型），Swift 就会对它进行强解包操作。上述代码中，可选值 `assumedString` 在执行为 `implicitString` 赋值的操作前被强解包，因为 `implicitString` 的类型是一个明确的、非可选的 `String` 类型。而下面的代码中，`optionalString` 并没有一个明确的类型，因此它就只会是一个普通的可选值类型。

```swift
let optionalString = assumedString
// optionalString 的类型是 "String?"，并且此处的 assumedString 也不会被强解包。
```

&#160; &#160; &#160; &#160; 当然，如果尝试获取一个本身是 `nil` 的隐式解包可选值的真实值，依然会触发一个运行时错误。此时相比于尝试用叹号强解包一个没有真实值的普通可选值的操作，二者效果是一样的。

&#160; &#160; &#160; &#160; 正如对普通可选值的检查操作一样，可以比较判断隐式解包可选值是否为 `nil`：

```swift
if assumedString != nil {
    print(assumedString!)
}
// 打印“An implicitly unwrapped optional string.”
```

&#160; &#160; &#160; &#160; 也同样可以对隐式解包可选值进行可选值绑定，继而在一段语句中对其校验及解包：

```swift
if let definiteString = assumedString {
    print(definiteString)
}
// 打印“An implicitly unwrapped optional string.”
```

> _**说明**_
>
> &#160; &#160; &#160; &#160; 对于那些后续可能成为 `nil` 的变量，不要将其声明为隐式解包可选值。如果在变量声明周期内需要对其检查是否为 `nil`，就将其声明成一个普通的可选值。

## 错误处理

&#160; &#160; &#160; &#160; 当程序执行时遇到了错误情况，就可以用**错误处理[^3]（ _error handling_ ）**来响应执行。

&#160; &#160; &#160; &#160; 相较于可以通过真实值的拥有或缺失来表示函数执行得成功与否，错误处理可以明确确定错误的原因，甚至必要时，可以将错误转移至程序的其他地方。

&#160; &#160; &#160; &#160; 函数遇到错误条件时，它会**抛出（ _throws_ ）**一个错误。函数调用者可以**捕获（ _catch_）**这个错误并且适当地对其响应处理。

```swift
func canThrowAnError() throws {
    // 这是一个可能正常执行，也可能抛出一个错误的函数
}
```

&#160; &#160; &#160; &#160; 函数声明时可标注 `throws` 关键字来表示该函数可能抛出一个错误。如果调用了一个可能抛出异常的函数，需要预先对该表达式使用 `try` 关键字。

&#160; &#160; &#160; &#160; Swift 会自动将错误传递出当前的函数体，直至它们被一个 `catch` 语句捕获处理。

```swift
do {
    try canThrowAnError()
    // 执行到这里，说明没有抛出任何错误
} catch {
    // 执行到这里，说明有错误被抛出了
}
```

&#160; &#160; &#160; &#160; `do` 语句会创建一个新的逻辑体，它允许其中的错误被一个或多个 `catch` 语句所捕获。

&#160; &#160; &#160; &#160; 这是一段展示错误处理是如何响应处理不同错误情况的示例代码：

```swift
func makeASandwich() throws {
    // ...
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
```

&#160; &#160; &#160; &#160; 这段示例中，当没有干净的盘子或缺失任意烹饪原料时，`makeASandwich()` 函数就会抛出一个错误。因为 `makeASandwich()` 函数本身可以抛出一个错误，所以对此函数的调用需要用 `try` 表达式来标明。函数被 `do` 语句包围，因此其抛出的任何错误都将被相应的 `catch` 所捕获。

&#160; &#160; &#160; &#160; 如果没有错误抛出，`eatASandwich()` 函数就会被调用。如果抛出了一个可以匹配 `SandwichError.outOfCleanDishes` （无干净盘子）情况的错误，那么 `washDishes()` 函数就会被调用；如果抛出了一个可以匹配 `SandwichError.missingIngredients` （缺少烹饪原料）情况的错误，那么 `catch` 将捕获错误且将伴随绑定的 `[String]` 值传递给 `buyGroceries(_:) ` 函数并对其进行调用。

&#160; &#160; &#160; &#160; 关于抛出错误、捕获错误以及传递处理错误的更多细节，可以参考 [错误处理](./ErrorHandling.md) 章节。

## 断言与先决条件

&#160; &#160; &#160; &#160; **断言（ _assertions_ ）**和**先决条件（ _preconditions_ ）**是发生在运行阶段的检查。使用它们的目的是确保执行更多的代码逻辑前一些必要条件能够满足。如果断言或先决条件处评估的布尔条件值为 `true`，那么代码可以继续正常执行；如果条件值为 `false`，表明当前程序状态异常，代码执行结束、程序运行终止。

&#160; &#160; &#160; &#160; 断言和先决条件用于表示编码时做出的假设与预期，所以这些内容本就应当是代码的一部分。断言用于在开发阶段发现错误和不正确的假设，而先决条件用于在生产阶段探测问题。

&#160; &#160; &#160; &#160; 除了用于确保运行时的预期，断言与先决条件也可以看作是代码中一种格外有帮助的文档。与上述在 [错误处理](#错误处理) 章节所讨论的错误条件不同，断言与先决条件并不会用于处理那些可恢复的、可预期的错误，因为断言或先决条件检查错误，就表明程序进入了异常状态，所以也无法去捕获一个错误的断言了。

&#160; &#160; &#160; &#160; 使用断言与先决条件并不意味着要依照不出现错误的思路来设计代码。而是用它们来确保数据及状态的合理性，继而及时地在遇到异常状态时能及时地、针对性地终止程序运行，从而使得问题的调试更加简便。检测到异常状态就及时终止执行，也可以限制异常状态可能造成的危害（比如破坏数据等等）。

&#160; &#160; &#160; &#160; 断言与先决条件的差异在于它们触发检查的时机：断言只会在调试构建时触发检查，而先决条件在调试构建和正式构建时都会触发检查。正式构建阶段，断言的检查条件不会被触发。这也就意味着在开发阶段可以在任意想要校验的地方使用断言，而这并不会影响最终正式版本的性能。

### 用断言调试

&#160; &#160; &#160; &#160; 断言需要调用 Swift 标准库的 [`assert(_:_:file:line:)`](https://developer.apple.com/documentation/swift/1541112-assert) 函数。调用时需要向函数传递一个可以计算得到 `true` 或 `false` 的条件表达式以及一条能够在计算结果为 `false` 时展示的反馈信息。比如：

```swift
let age = -3
assert(age >= 0, "A person's age can't be less than zero.")
// 这条断言检查失败，因为 -3 并不满足条件 >= 0
```

&#160; &#160; &#160; &#160; 这个示例中，如果 `age >= 0` 计算结果为 `true`（即年龄值是一个非负数）时，程序会继续执行。而像上述代码中，`age` 值是一个负数，那么 `age >= 0` 求值的结果就是 `false`，所以断言检查失败，程序终止执行。

&#160; &#160; &#160; &#160; 如果只是想检查条件本身，也可以省略掉断言反馈信息。

```swift
assert(age >= 0)
```

&#160; &#160; &#160; &#160; 如果逻辑已经检查了相应的条件，依然可以直接使用 [`assertionFailure(_:file:line:)`](https://developer.apple.com/documentation/swift/assertionfailure(_:file:line:)) 函数来表明断言检查失败。比如：

```swift
if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age >= 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}
```

### 用先决条件确保逻辑

&#160; &#160; &#160; &#160; 如果一个检查条件潜在性地得到 `false` 的计算结果，但实际又必须**明确地（ _definitely_ ）**需要它为 `true` 才能继续执行，此时就需要使用先决条件。比如说：用先决条件来检查确保下标值没有越界、或用来检查确保向函数传递的值是合理有效的。

&#160; &#160; &#160; &#160; 通过调用 [`precondition(_:_:file:line:)`](https://developer.apple.com/documentation/swift/1540960-precondition) 函数来创建一个先决条件。向这个函数传递一个可以计算得到 `true` 或 `false` 的条件表达式以及一条能够在计算结果为 `false` 时展示的反馈信息。比如：

```swift
// 一种「下标」的实现...
precondition(index > 0, "Index must be greater than zero.")
```

&#160; &#160; &#160; &#160; 也可以调用 [`preconditionFailure(_:file:line:)`](https://developer.apple.com/documentation/swift/1539374-preconditionfailure) 函数来表明一个错误发生了。比如：switch 语句的默认情况被触发了，而原本所有合法的输入均可被 switch 的其他分支处理到。

> _**说明**_
>
> &#160; &#160; &#160; &#160; 如果在无检查模式（-Ounchecked）下编译，先决条件是不会被检查的。此时编译器会假定所有的先决条件检查值均为 true，并对代码进行相应的优化。而 `fatalError(_:file:line:)` 则会无视任何优化设置（编译选项），总是会中断执行。
>
> &#160; &#160; &#160; &#160; `fatalError(_:file:line:)` 函数可用于原型设计和早期开发阶段，此时可能需要定义一些未实现的功能性接口（ _stubs_ ）[^4]，那么就可以将 `fatalError(_:file:line:)` 作为这些接口的默认实现。由于致命错误与断言或先决条件不同，它本身并不会被优化掉进而不被触发，所以可以确保正常执行时如果遇到了这些（未完善定义的）接口，程序总是会中断。

---

[^1]: **量值**一般表示常量或变量，有时也表示常量或变量的值，请注意结合上下文区分。
[^2]: 正如前面讨论的，如果尝试访问一个值为 `nil` 的可选值，程序会抛出一个运行时错误，那么此时的的程序大概率会执行异常，所以此时触发错误的操作，就是一个**不安全**的操作。
[^3]: 与其他语言的**异常**概念类似，后续可能会穿插使用“异常”一词来描述 Swift 的“错误”，请注意结合上下文区分。
[^4]: 实际指的应当是一些未完善定义的功能接口。开发流程中，前期为确保程序框架的整体性，经常需要定义一些接口，而这些接口的实现是需要后续根据实际业务需求来定义完善的。开发过程中如果忽略了对一些非完善接口逻辑的补充，其后果往往很难探测得到。因而默认这些非完善接口的实现是一定会导致程序的中断，可以及时地发现这些接口，进而及时修复和完善相关的定义及实现。
